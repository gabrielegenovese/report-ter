The use of the actor model to conceptualize and create concurrent programs has led the scientific community to focus on solving long-known but challenging behavioral problems and on verifying semantic properties (e.g. liveness, lock and deadlock freedom). One of the mathematical models developed in recent years is \textbf{choreographies}: a formal model used to represent systems of communicating processes, enabling semantic proofs regarding the presence or absence of the mentioned properties. Choreographies are \textbf{global views} of the behavior of a system, giving a comprehensive perspective of the communication exchanges among actors (also called participants). From the global view, via a simple projection, one can obtain the \textbf{local view}, i.e., the individual behavior of each participant in the communication process. 
%This separation between global and local views not only simplifies understanding and reasoning about complex interactions but also aids in the verification of properties specific to each local participant. 
Notice that, the local view is limited and actors are unaware of the behavior of the rest of the system.

\bigskip

A \textit{visual} way to formalize choreographies is through \textbf{Choreographic Automata} \cite{barbanerachoreography}, which describe a communication system using a set of finite-state automata. Representing choreographies using FSA is particularly well-suited for illustrating the program flow, as it clearly shows loops and branching, while using previously described results and notions. \cite{orlando2021corinne}. 

\bigskip
The goal of this project is to build a tool that starting from an existing Erlang program extracts the choreographic specification in the form of Choreographic Automata. This  amounts to first extract the local views corresponding to each actor and then  combine the local views into the global choreography. This step  is a sort of inverse operation with respect to the projection and will not be always possible. To illustrate what it means to extract a choreography from an Erlang program, consider the following example.

\begin{exmp}[Extraction example]

Take two actors: a \texttt{main} and a \texttt{dummy} process. These two actors subsequently exchange a  message. However, one of the actors will execute \textit{send} first and then \textit{receive}, while the other actor will perform the operations in reverse order. Therefore, the expected graph should show a single line of execution, where the exchange of \texttt{ciao} occurs first, followed by the exchange of \texttt{bello}.


\begin{lstlisting}[language=Erlang, caption=Two processes exchanging messages synchronously, label=code:noasync]
-module(simple).
-export([main/0, dummy/0]).

main() ->
    D = spawn(simple, dummy, [self()]),
    D ! ciao,
    receive
        bello -> done
    end.

dummy(M) ->
    receive
        ciao -> done
    end,
    M ! bello.
\end{lstlisting}

Listing \ref{code:noasync} shows  to the described scenario in Erlang. The \texttt{dummy} process sends the atom \texttt{ciao} to the \texttt{main} process. This action unlocks the sending of the atom \texttt{bello} to \texttt{dummy}. Figures \ref{local:main} and \ref{local:dummy1a} depict the local views of the actors.

\bigskip

\begin{figure}[ht!]
    \centering
    \resizebox{.9\textwidth}{!}{%
        \begin{tikzpicture}[node distance={33mm}, thick, main/.style = {draw, circle}] 
          \node[initial, state] (n_1) {1};
          \node[state] (n_2) [right of=n_1] {2};
          \node[state] (n_3) [right of=n_2] {3};
          \node[state,accepting] (n_4) [right of=n_3] {4};
          
          \draw[->] (n_1) -- node[midway, above, pos=0.5] {$\Delta$ dummy} (n_2);
          \draw[->] (n_2) -- node[midway, above, pos=0.5] {dummy ! ciao} (n_3);
          \draw[->] (n_3) -- node[midway, above, pos=0.5] {receive bello} (n_4);
        \end{tikzpicture}
    }
    \caption{Local view of \texttt{main}}
    \label{local:main}
\end{figure}


\begin{figure}[ht!]
    \centering
    \resizebox{.8\textwidth}{!}{%
        \begin{tikzpicture}[node distance={40mm}, thick, main/.style = {draw, circle}] 
          \node[initial, state] (n_1) {1};
          \node[state] (n_2) [right of=n_1] {2};
          \node[state, accepting] (n_3) [right of=n_2] {3};
          
          \draw[->] (n_1) -- node[midway, above, pos=0.5] {receive ciao} (n_2);
          \draw[->] (n_2) -- node[midway, above, pos=0.5] {M ! bello} (n_3);
        \end{tikzpicture}
    }
    \caption{Local view of \texttt{dummy}}
    \label{local:dummy1a}
\end{figure}

After associating the local views with the actors, the algorithm generates the global view shown in Figure \ref{global:noasync}. As expected, the automaton in Figure \ref{global:noasync} expresses only one possible global execution of the program: from State 1 to State 2 the actor with the unique identifier \texttt{main} spawns the actor with the  identifier \texttt{dummy}, and then from State 2 to State 3 \texttt{main} sends successfully the message \texttt{ciao} to \texttt{dummy}. Finally, from State 3 to State 4, \texttt{dummy} will response to \texttt{main} with \texttt{bello}.

\begin{figure}[ht!]
    \centering
    \resizebox{\textwidth}{!}{%
        \begin{tikzpicture}[node distance={43mm}, thick, main/.style = {draw, circle}] 
          \node[initial, state] (n_1) {1};
          \node[state] (n_2) [right of=n_1] {2};
          \node[state] (n_3) [right of=n_2] {3};
          \node[state, accepting] (n_4) [right of=n_3] {4};
          
          \draw[->] (n_1) -- node[midway, above, pos=0.5] {main$\Delta$dummy} (n_2);
          \draw[->] (n_2) -- node[midway, above, pos=0.5] {main$\to$dummy:ciao} (n_3);
          \draw[->] (n_3) -- node[midway, above, pos=0.5] {dummy$\to$main:bello} (n_4);
        \end{tikzpicture}
    }
    \caption{Global view of Code \ref{code:noasync}}
    \label{global:noasync}
\end{figure}
\end{exmp}
