Significant effort has been dedicated to developing a 
generic and automated script (written in Python) to test the tool and extract 
relevant information about the tool and its output.
Table~\ref{tab:gvbench} presents empirical data on the evaluation of various 
examples processed by the tool. 
The examples are primarily designed ad hoc to test specific aspects of the tool.
They are not sourced from well-known Erlang suites, as the tool is still in an
early stage and cannot yet parse most of them.
The columns of Table~\ref{tab:gvbench} provide the following information:

\begin{itemize}
    \item \textbf{Example}: Name of the test case.
    \item \textbf{Lines}: Number of lines of code in the example.
    \item \textbf{Tot LV}: Total number of local views generated by the example.
    \item \textbf{GV Nodes}: Number of nodes in the global view graph.
    \item \textbf{GV Edges}: Number of edges in the global view graph.
    \item \textbf{Warns}: Number of warnings raised.
    \item \textbf{Errors}: Number of errors detected (i.e. deadlocks).
    \item \textbf{Time}: Execution time in seconds.
\end{itemize}

The entries are ordered by the number of lines of code. The generated graphs 
included in the table are presented without minimization. Applying minimization 
techniques to the global view graph can lead to incorrect reductions in some 
cases, cause of a known bug. Therefore, we opted to maintain the full 
graph representation to ensure correctness.

\paragraph{Analysis of global view empirical data}
From the Table~\ref{tab:gvbench}, we can observe the overall behavior of the tool, 
focusing on the number of warnings and errors in the output. 
As previously mentioned, a high number of message exchanges directly correlates  
with an increased number of nodes and edges in the global view.
Warnings usually occur when the
tool encounters unknown elements in the source code, such as a new keyword or
an external function. They also appear when the tool loses track of a process
identifier, preventing it from mapping message exchanges correctly. 
This occurs in the \texttt{if-cases} example, which generates 185 warnings due to
the tool's failure to instantiate a variable with the correct process identifier,
making it unable to deliver the corresponding message. This issue likely stems 
from a bug in the actor emulation module.
Errors typically arise when an unexpected situation occurs or when a deadlock
state is detected. Most examples do not automatically terminate a process once
it completes its task (e.g., waiting for requests), which contributes to this
issue. However, one particularly notable case is \texttt{foo8}, which has 561
nodes, 560 edges, and 191 errors. The reason lies in its heavy use of case
constructsâ€”some information is lost between the local and global views, leading
the tool to explore every possible execution path. This results in a high number
of states, edges, and undefined deadlock conditions. 
Using a minimized version of the local graph during actor emulation can
significantly reduce these values. However, this conflicts with the principle
of using an over-approximated approach. To address this, minimization could be
added as a program argument, allowing users to trade some generality for a
more precise global view graph.

\paragraph{About complexity}
A significant portion of the execution time is obviously consumed by the global  
view composition algorithm. This algorithm attempts to explore all possible  
program executions, considering every potential message order to meet the  
overapproximation requirement. In the worst-case scenario, without any  
restrictions, it must evaluate all permutations of messages, resulting in a  
factorial time complexity of \( O(n!) \). However, in most cases, more efficient  
strategies can be applied to mitigate this complexity.
The execution times show that our algorithm performs efficiently even on large 
examples (an example is considered large when there are many nodes and edges
because this corresponds to a high number of messages exchanged, leading to a
high number of possible combination of these messages), with the most complex 
cases (e.g., \texttt{foo8}) taking only a few seconds.

\begin{table}[!ht]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
Example & Lines & Tot LV & GV Nodes & GV Edges & Warns & Errors & Time \\ 
\hline
unknown & 13 & 2 & 2 & 2 & 0 & 0 & 0.175s \\ 
foo9 & 14 & 4 & 4 & 3 & 1 & 3 & 0.187s \\ 
foo9c & 15 & 3 & 10 & 15 & 0 & 0 & 0.182s \\ 
pass & 16 & 3 & 3 & 2 & 0 & 0 & 0.174s \\ 
foo9d & 16 & 3 & 3 & 2 & 0 & 0 & 0.186s \\ 
funcall & 17 & 3 & 4 & 3 & 1 & 2 & 0.180s \\ 
forloop & 18 & 3 & 7 & 6 & 0 & 0 & 0.188s \\ 
foo1 & 18 & 3 & 8 & 7 & 0 & 0 & 0.175s \\ 
foo5 & 18 & 3 & 79 & 165 & 1 & 0 & 0.316s \\ 
async & 20 & 3 & 7 & 6 & 0 & 0 & 0.194s \\ 
foo4 & 20 & 4 & 16 & 19 & 0 & 2 & 0.182s \\ 
hof & 21 & 4 & 15 & 17 & 0 & 3 & 0.189s \\ 
foo9b & 21 & 4 & 4 & 4 & 14 & 1 & 0.183s \\ 
spawn & 22 & 3 & 9 & 8 & 0 & 0 & 0.179s \\ 
foo3 & 22 & 3 & 13 & 16 & 0 & 0 & 0.178s \\ 
account & 23 & 3 & 28 & 39 & 0 & 2 & 0.211s \\ 
airline & 23 & 3 & 15 & 26 & 1 & 0 & 0.232s \\ 
foo2 & 23 & 4 & 4 & 3 & 1 & 1 & 0.180s \\ 
foo9h & 23 & 4 & 24 & 35 & 0 & 5 & 0.196s \\ 
hello & 24 & 3 & 5 & 6 & 2 & 0 & 0.190s \\ 
trick & 24 & 4 & 9 & 9 & 0 & 0 & 0.184s \\ 
foo6 & 24 & 5 & 9 & 9 & 15 & 2 & 0.190s \\ 
foo9e & 24 & 5 & 14 & 14 & 0 & 5 & 0.186s \\ 
foo9f & 25 & 5 & 7 & 6 & 0 & 4 & 0.183s \\ 
foo9g & 25 & 5 & 44 & 83 & 0 & 7 & 0.226s \\ 
conditional & 26 & 2 & 25 & 24 & 1 & 16 & 0.197s \\ 
foo8 & 29 & 5 & 561 & 560 & 0 & 191 & 3.590s \\ 
producer & 30 & 4 & 11 & 10 & 0 & 1 & 0.183s \\ 
dining & 31 & 3 & 45 & 72 & 0 & 2 & 0.232s \\ 
ticktackloop & 32 & 4 & 6 & 6 & 2 & 0 & 0.182s \\ 
airline & 33 & 3 & 35 & 68 & 1 & 0 & 0.232s \\ 
ping & 36 & 3 & 6 & 5 & 1 & 0 & 0.188s \\ 
meViolation & 40 & 4 & 63 & 82 & 2 & 4 & 0.266s \\ 
serverclient & 41 & 5 & 9 & 8 & 8 & 3 & 0.187s \\ 
foo7 & 41 & 3 & 149 & 229 & 0 & 6 & 0.513s \\ 
ticktackstop & 46 & 5 & 19 & 27 & 7 & 0 & 0.214s \\ 
purchase & 47 & 5 & 49 & 66 & 6 & 0 & 0.257s \\ 
customer & 54 & 5 & 17 & 22 & 1 & 0 & 0.205s \\ 
if-cases & 57 & 4 & 148 & 210 & 185 & 30 & 0.525s \\ 
\hline
\end{tabular}
\caption{Global view empirical data}
\label{tab:gvbench}
\end{table}

\paragraph{Correctness of Global View}
One of the main contributions was enabling automatic verification of whether a
global view matches its correct version. Since knowing the complete specification
in advance is not trivial, we conducted tests on a few selected examples. 
The correct versions of the graph can be seen as what we expect to be the final
global view.
Table~\ref{tab:corrbench} briefly shows the correctness of the global view. 
The \textbf{Check} column indicates whether the global view 
correctly represents the expected behavior. Some examples, such as 
\texttt{async} and \texttt{ticktackloop}, are correctly generated because they 
are very simple example, while others fail. This may result from a missing 
feature in local or global view generation or from
the expected version not aligning with actual results. A key future goal of the
project is to generate as many correct global view versions as possible and to
systematically check and refine each one.

\begin{table}[!ht]
\centering
\begin{tabular}{|c|c|}
\hline
Example & Check \\ 
\hline
unknown & False \\ 
async & True \\ 
ticktackloop & True \\ 
ticktackstop & False \\ 
customer & False \\ 
\hline
\end{tabular}
\caption{Global view correctness data}
\label{tab:corrbench}
\end{table}
