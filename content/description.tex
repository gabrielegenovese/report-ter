
\paragraph{How to use the tool}
The tool can be used from the command line interface (CLI). It can be used by compiling each module from the Erlang Shell (Eshell) or, more conveniently, by using \texttt{rebar3}, a standard build tool that provides various features such as package management for community-created libraries, compilation, and automated project testing. By cloning the project from the public GitHub repository and running the \texttt{rebar3 escriptize} command in the main directory, \texttt{rebar3} will, in this order, check for and download dependencies if needed, compile the project, and run tests if present. After that, an executable can be used in \texttt{./\_build/default/bin/chorer}.

\begin{lstlisting}[caption=Usage message]
Usage:
  chorer <input> <entrypoint> <output> <ming> <gstate> <minl>

Extract a choreography automata of an Erlang program.

Arguments:
  input      Erlang soure file (string)
  entrypoint Entrypoint of the program (atom)
  output     Output directory for the generated dot files (string), default: ./
  ming       Minimize the globalviews , default: false
  gstate     Global state are formed with previous messages , default: true
  minl       Minimize the localviews , default: true
\end{lstlisting}

\noindent The mandatory arguments are:
\begin{itemize}
    \item \textbf{Input}: The relative path string of the input Erlang program, from which the tool will generate local and global views.
    \item \textbf{Entrypoint}: The atom representing the function where the execution of the input program begins. This parameter is essential because Erlang does not have a conventional entry point function (i.e. the main in C, but in Erlang can be every exported function). It will be passed to the function that creates the global view to start the simulation.
\end{itemize}

\noindent The optional arguments are:
\begin{itemize}
    \item \textbf{Output}: The relative path string of the output folder where the local and global view files will be saved. Local views will be named \texttt{[function name with arity]\_local\_view.dot}, while the global view file will be named \texttt{[Entrypoint]\_global\_view.dot}.
    \item \textbf{Options}: Currently, this is a tuple of two booleans that allow customization of local views. The first boolean determines whether to identify final states (by default, it is set to true). The second adds more information to the local view by including transitions related to other language constructs in addition to communication constructs (by default, it is set to false). This parameter may be expanded in the future with additional booleans.
\end{itemize}

\begin{lstlisting}[language=Erlang, caption=Use example of the tool]
 shell> ./_build/default/bin/chorer ./path/to/file.erl entrypoint/0
\end{lstlisting}

\paragraph{Struttura del tool}
Il progetto si divide in due cartelle principali. Sotto la cartella \texttt{examples} ci sono vari esempi di programmi in Erlang su cui provare il tool. Il codice del tool si trova invece nella cartella \texttt{src}. 

\bigskip

\dirtree{%
.1 chorer.
.2 examples.
.3 ....
.2 src.
.3 choreography.
.4 actor\_emul.erl.
.4 eval.erl.
.4 gv.erl.
.4 lv.erl.
.4 md.erl.
.3 common.
.4 common\_data.hrl.
.4 db.erl.
.4 digraph\_to\_dot.erl.
.4 fsa.erl.
.4 log.erl.
.4 settings.erl.
.4 share.erl.
.3 chorer\_app.erl.
.3 chorer.app.src.
.2 rebar.config.
.2 rebar.lock.
}

\bigskip

Il file principale \`e \texttt{chorer\_app.erl}, dove si trova la funzione \texttt{start}. I file \texttt{rebar.config}, \texttt{rebar.lock} e \texttt{chorer.app.src} servono a far funzionare il tool \texttt{rebar3}. Nella cartella \texttt{choreography} si trovano i moduli adibiti all'analisi statica del programma e alla creazione delle viste locali e globali. In particolare, il modulo \texttt{db\_manager.erl} si occupa della gestione di dati in comune, utile per non passare tanti dati attraverso i parametri delle funzioni. I moduli \texttt{metadata.erl}, \texttt{local\_view.erl} e \texttt{global\_view.erl} si occupano rispettivamente di gestire l'estrazione dei dati preliminari, la creazione delle viste locali e la creazione della vista globale. Invece, nella cartella \texttt{common} si trovano le funzioni ``in comune" per tutti i moduli, quindi la gestione e minimizzazione degli automi (in \texttt{fsa.erl}), la conversione di un grafo in formato DOT (in \texttt{digraph\_to\_dot.erl}) e il salvataggio su file (in \texttt{common\_fun.erl}). Il file \texttt{common\_data.hrl} contiene le strutture dati utilizzate nel progetto.


\subsubsection{From Erlang to Choreographies}
\label{sec:corrisp}
In questa sezione, verranno definite le corrispondenze tra codice in Erlang e automa coreografico, rispettivamente per viste locali e globali.

\paragraph{Viste locali}

Il codice di un'operazione \texttt{receive} (come nel codice \ref{code:receive}) corrisponde al grafo \ref{grafo:receive}; ogni ramo verr\`a valutato ricorsivamente, continuando quindi la costruzione dai rami; infine, tutti i rami si ricongiungeranno su un nodo comune con delle transizioni $\epsilon$, dal quale ripartir\`a la valutazione della vista locale. L'operazione \texttt{Pid ! message} corrisponde al grafo \ref{grafo:send}. La chiamata alla funzione \texttt{spawn} corrisponde al grafo \ref{grafo:spawn}.

\bigskip

\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={29mm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {1};
      \node[state] (n_2) [above right of=n_1] {2};
      \node[state] (n_4) [below right of=n_1] {$n$};
      \node[state] (n_3) [below=\distance cm of n_2] {\ldots};
      \node[state] (n_5) [right of=n_2] {\ldots};
      \node[state] (n_6) [right of=n_3] {\ldots};
      \node[state] (n_7) [right of=n_4] {$m$};
      \node[state] (n_8) [below right of=n_5] {$m+1$};
      
      \draw[->] (n_1) -- node[midway, above left, pos=0.6] {receive message1} (n_2);
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {...} (n_3);
      \draw[->] (n_1) -- node[midway, below left, pos=0.6] {receive messageN} (n_4);
      \draw[->] (n_2) -- node[midway, above, pos=0.5] {...} (n_5);
      \draw[->] (n_3) -- node[midway, above, pos=0.5] {...} (n_6);
      \draw[->] (n_4) -- node[midway, above, pos=0.5] {...} (n_7);
      \draw[->] (n_5) -- node[midway, above, pos=0.5] {$\epsilon$} (n_8);
      \draw[->] (n_6) -- node[midway, above, pos=0.5] {$\epsilon$} (n_8);
      \draw[->] (n_7) -- node[midway, above, pos=0.5] {$\epsilon$} (n_8);
    \end{tikzpicture}
    \caption{Grafo locale per il costrutto \texttt{receive}}
    \label{grafo:receive}
\end{figure}


\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={50mm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {1};
      \node[state] (n_2) [right of=n_1] {2};
      
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {ProcSent ! message} (n_2);
    \end{tikzpicture}
    \caption{Grafo locale per il costrutto \texttt{!}}
    \label{grafo:send}
\end{figure}

\bigskip

\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={40mm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {1};
      \node[state] (n_2) [right of=n_1] {2};
      
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {$\Delta$ process} (n_2);
    \end{tikzpicture}
    \caption{Grafo locale per il costrutto \texttt{spawn}}
    \label{grafo:spawn}
\end{figure}


\paragraph{Chiamate di funzioni}
Essendo un linguaggio di programmazione funzionale, vengono eseguite numerose chiamate di funzione. Le funzioni possono essere presenti nello stesso file, in un modulo differente, oppure possono essere funzioni \textit{built-in}. Di seguito vengono mostrate le chiamate di funzioni che modificano il comportamento del grafo.

\paragraph{Chiamate ricorsive}

Nel caso delle chiamate \textit{ricorsive}, si crea una transizione $\epsilon$ dall'ultimo nodo creato fino al primo nodo, come mostrato in figura \ref{grafo:ricors}.

\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={3cm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {1};
      \node[state] (n_2) [right of=n_1] {\ldots};
      \node[state] (n_3) [right of=n_2] {$n$};
      
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {\ldots} (n_2);
      \draw[->] (n_2) -- node[midway, above, pos=0.5] {\ldots} (n_3);
      \draw[->] (n_3) to [out=120,in=60] node[midway, above, pos=0.5] {$\epsilon$} (n_1);
    \end{tikzpicture}
    \caption{Grafo della chiamata ricorsiva di una funzione}
    \label{grafo:ricors}
\end{figure}

\paragraph{Chiamata a una funzione generica}
Quando si incontra in chiamata ad una funzione non conosciuta, l'algoritmo creer\`a la vista locale della funzione chiamata e ``collegher\`a" l'inizio del grafo della funzione chiamata con l'ultimo stato creato nella vista locale della funzione chiamante, collegandolo con una transizione $\epsilon$. La vista locale continuer\`a dall'ultimo vertice del grafo della chiamata.

\bigskip

\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={2cm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {$1_a$};
      \node[state] (n_2) [right of=n_1] {\ldots};
      \node[state] (n_3) [right of=n_2] {$n$};
      \node[state] (n_4) [right of=n_3] {$1_b$};
      \node[state] (n_5) [right of=n_4] {\ldots};
      
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {\ldots} (n_2);
      \draw[->] (n_2) -- node[midway, above, pos=0.5] {\ldots} (n_3);
      \draw[->] (n_3) -- node[midway, above, pos=0.5] {$\epsilon$} (n_4);
      \draw[->] (n_4) -- node[midway, above, pos=0.5] {\ldots} (n_5);
    \end{tikzpicture}
    \caption{Grafo di una chiamata di funzione}
    \label{grafo:funcall}
\end{figure}

Nel grafo \ref{grafo:funcall}, lo stato $1_a$ \`e lo stato iniziale della funzione chiamante e lo stato $1_b$ indica il primo stato della vista locale della funzione chiamata.

\paragraph{Viste globali}

Per le viste globali, nelle \texttt{spawn} si specifica l'attore che esegue l'operazione a sinistra del simbolo come mostrato nella figura \ref{grafo:globspawn}. Una spawn verr\`a direttamente inserita nel grafo. Ogni processo verr\`a anche numerato, nel caso vengano creati molteplici attori per la stessa funzione.

\bigskip

\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={7cm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {1};
      \node[state] (n_2) [right of=n_1] {2};
      
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {ProcSpawner$_n\Delta$ProcSpawned$_m$} (n_2);
    \end{tikzpicture}
    \caption{Grafo globale per il costrutto \texttt{spawn}}
    \label{grafo:globspawn}
\end{figure}

\bigskip

Per l'invio e la ricezione di messaggi, durante la simulazione degli attori, se vengono trovati due attori che eseguono una send e una receive compatibile, allora verr\`a aggiunta alla vista globale uno stato come in figura \ref{grafo:sendrecv}. Per essere compatibili, il processo ricevente deve corrispondere al destinatario dei dati e il pattern matching della receive deve combaciare con i dati inviati. Le transizioni \textit{send} e \textit{receive} fatte a ``vuoto" (cio\`e i messaggi che vengono inviati, ma non vengono processati da una \textit{receive} di un qualsiasi processo) non verranno mostrate nell'automa globale.

\bigskip

\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={8cm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {1};
      \node[state] (n_2) [right of=n_1] {2};
      
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {ProcSender$_n\to$ ProcRecv$_m$ : message} (n_2);
    \end{tikzpicture}
    \caption{Grafo globale per \texttt{receive} e \texttt{!}}
    \label{grafo:sendrecv}
\end{figure}


\subsubsection{Main algorithms}
\input{content/algorithms}

\paragraph{Old state}

The tool can accurately parse the main constructs and features of the Erlang language. In Table \ref{erl}, we outline the current status: what is supported, what is not supported, and what are the next objectives. It was decided not to support certain constructs because they are not useful at this stage of the project. For example, supporting error handling with try-catch is unnecessary when variable passing is not yet implemented. Additionally, some constructs were excluded because they are orthogonal to others, such as complex data structures. The tool generates a local view that closely aligns with the behavior of the original actor, and the algorithm for combining local views into a global view performs well on simple examples. However, at present, it does not provide automatic error detection for certain properties in the global choreography.

% \begin{table}[!ht]
%     \centering
%     \begin{minipage}{0.49\textwidth}
%     \centering
%     \begin{tabular}{|c||c|}
%     \hline \textbf{Keyword} & \textbf{Support}    \\  \hline
%      atom & \cellcolor{ashgrey}yes    \\  \hline
%      integer & \cellcolor{ashgrey}yes \\   \hline
%      float &\cellcolor{ashgrey}yes    \\   \hline
%      boolean &\cellcolor{ashgrey}yes    \\   \hline
%      tuple & \cellcolor{ashgrey}yes    \\   \hline
%      list &\cellcolor{ashgrey}yes    \\   \hline
%      record & \cellcolor{red!50}no   \\   \hline
%      map & \cellcolor{red!50}no   \\   \hline
%      binary & \cellcolor{red!50}no    \\   \hline
%      if & \cellcolor{ashgrey}yes    \\   \hline
%      case & \cellcolor{ashgrey}yes    \\   \hline
%      receive &\cellcolor{ashgrey}yes    \\   \hline
%     \end{tabular}
%     \end{minipage}
%     \centering
%     \begin{minipage}{0.49\textwidth}
%     \begin{tabular}{|c||c|}
%     \hline \textbf{Keyword} & \textbf{Support}    \\  \hline
%      ! & \cellcolor{ashgrey}yes    \\   \hline
%      assignment &\cellcolor{ashgrey}yes    \\   \hline
%      function & \cellcolor{green!50}goal  \\   \hline
%      recursion & \cellcolor{green!50}goal   \\   \hline
%      hof &\cellcolor{green!50}goal    \\   \hline
%      when & \cellcolor{red!50}no    \\   \hline
%      self &\cellcolor{ashgrey}yes    \\   \hline
%      spawn &\cellcolor{ashgrey}yes    \\   \hline
%      rand:uniform &\cellcolor{ashgrey}yes    \\   \hline
%      try catch & \cellcolor{red!50}no    \\   \hline
%      after & \cellcolor{red!50}no    \\   \hline
%      math operation &\cellcolor{red!50}no    \\   \hline
%     \end{tabular} 
%     \end{minipage}
    
%     \caption{Supported constructs: Keywords in gray are already supported, keywords in red are not supported and are unlikely to be supported soon. Constructs in green are related to functions, because parameter passing is not supported.}
%     \label{erl}
% \end{table}