
\paragraph{How to use the tool}
The tool can be used from the command line interface (CLI). It can be used by compiling each module from the Erlang Shell (Eshell) or, more conveniently, by using \texttt{rebar3}, a standard build tool that provides various features such as package management for community-created libraries, compilation, and automated project testing. By cloning the project from the public GitHub repository and running the \texttt{rebar3 escriptize} command in the main directory, \texttt{rebar3} will, in this order, check for and download dependencies if needed, compile the project, and run tests if present. After that, an executable can be used in \texttt{./\_build/default/bin/chorer}.

\begin{lstlisting}[caption=Usage message]
Usage:
  chorer <input> <entrypoint> <output> <ming> <gstate> <minl>

Extract a choreography automata of an Erlang program.

Arguments:
  input      Erlang soure file (string)
  entrypoint Entrypoint of the program (atom)
  output     Output directory for the generated dot files (string), default: ./
  ming       Minimize the globalviews , default: false
  gstate     Global state are formed with previous messages , default: true
  minl       Minimize the localviews , default: true
\end{lstlisting}

\noindent The mandatory arguments are:
\begin{itemize}
    \item \textbf{Input}: The relative path string of the input Erlang program, from which the tool will generate local and global views.
    \item \textbf{Entrypoint}: The atom representing the function where the execution of the input program begins. This parameter is essential because Erlang does not have a conventional entry point function (i.e. the main in C, but in Erlang can be every exported function). It will be passed to the function that creates the global view to start the simulation.
\end{itemize}

\noindent The optional arguments are:
\begin{itemize}
    \item \textbf{Output}: The relative path string of the output folder where the local and global view files will be saved. Local views will be named \texttt{[function name with arity]\_local\_view.dot}, while the global view file will be named \texttt{[Entrypoint]\_global\_view.dot}.
    \item \textbf{Options}: Currently, this is a tuple of two booleans that allow customization of local views. The first boolean determines whether to identify final states (by default, it is set to true). The second adds more information to the local view by including transitions related to other language constructs in addition to communication constructs (by default, it is set to false). This parameter may be expanded in the future with additional booleans.
\end{itemize}

\begin{lstlisting}[language=Erlang, caption=Use example of the tool]
shell> ./_build/default/bin/chorer ./path/to/file.erl entrypoint/0
...
[INFO] Finished!
\end{lstlisting}

\paragraph{Struttura del tool}
The project is divided into two main folders. Under the folder \texttt{examples},
there are various examples of Erlang programs to test the tool. The tool's code
is located in the \texttt{src} folder.

\bigskip

\dirtree{%
.1 chorer.
.2 examples.
.3 ....
.2 src.
.3 choreography.
.4 actor\_emul.erl.
.4 eval.erl.
.4 gv.erl.
.4 lv.erl.
.4 md.erl.
.3 common.
.4 common\_data.hrl.
.4 db.erl.
.4 digraph\_to\_dot.erl.
.4 fsa.erl.
.4 log.erl.
.4 settings.erl.
.4 share.erl.
.3 chorer\_app.erl.
.3 chorer.app.src.
.2 rebar.config.
.2 rebar.lock.
}

\bigskip

The main file is \texttt{chorer\_app.erl}, which contains the \texttt{main} function.  
The file \texttt{rebar.config}, \texttt{rebar.lock}, and \texttt{chorer.app.src} are required for running the tool with \texttt{rebar3}.  
The \texttt{choreography} folder contains modules responsible for the static analysis of the program and the creation of local and global views. Specifically:  
\begin{itemize}  
    \item \texttt{actor\_emul.erl}: manage the emulation of an actor during the globalview creating.
    \item \texttt{eval.erl}: helps the localview generation.  
    \item \texttt{gv.erl}: generates the globalview.  
    \item \texttt{lv.erl}: generates the localviews.  
    \item \texttt{md.erl}: manages the extraction of preliminary data.  
  \end{itemize}  

\noindent The \texttt{share} folder contains shared functions for all modules, including:  
\begin{itemize}  
  \item \texttt{common\_data.erl}: header file where the main data structures are defined.  
  \item \texttt{db.erl}: manages the common information used during the creation
  of both local and global view.  
  \item \texttt{digraph\_to\_dot.erl}: converts a graph into DOT format.  
  \item \texttt{fsa.erl}: manages and minimizes automata.  
  \item \texttt{log.erl}: manages the logging of messages.  
  \item \texttt{settings.erl}: manages the settings of the program.  
  \item \texttt{share.erl}: handles file saving and shared function.  
\end{itemize}  

\subsubsection{From Erlang to Choreographies}
\label{sec:corrisp}

\paragraph{Localview}

The code of a \texttt{receive} operation corresponds to the Figure \ref{grafo:receive}:
each branch will be evaluated recursively, continuing the construction from the 
branches. Finally, all branches will merge into a common node with $\epsilon$ 
transitions, from which the evaluation of the local view will resume.  
The send operation (\texttt{Pid ! message}) operation corresponds to Figure \ref{grafo:send}.  
The \texttt{spawn} function call corresponds to Figure \ref{grafo:spawn}.  

\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={29mm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {1};
      \node[state] (n_2) [above right of=n_1] {2};
      \node[state] (n_4) [below right of=n_1] {$n$};
      \node[state] (n_3) [below=\distance cm of n_2] {\ldots};
      \node[state] (n_5) [right of=n_2] {\ldots};
      \node[state] (n_6) [right of=n_3] {\ldots};
      \node[state] (n_7) [right of=n_4] {$m$};
      \node[state] (n_8) [below right of=n_5] {$m+1$};
      
      \draw[->] (n_1) -- node[midway, above left, pos=0.6] {receive message1} (n_2);
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {...} (n_3);
      \draw[->] (n_1) -- node[midway, below left, pos=0.6] {receive messageN} (n_4);
      \draw[->] (n_2) -- node[midway, above, pos=0.5] {...} (n_5);
      \draw[->] (n_3) -- node[midway, above, pos=0.5] {...} (n_6);
      \draw[->] (n_4) -- node[midway, above, pos=0.5] {...} (n_7);
      \draw[->] (n_5) -- node[midway, above, pos=0.5] {$\epsilon$} (n_8);
      \draw[->] (n_6) -- node[midway, above, pos=0.5] {$\epsilon$} (n_8);
      \draw[->] (n_7) -- node[midway, above, pos=0.5] {$\epsilon$} (n_8);
    \end{tikzpicture}
    \caption{Localview graph for the \texttt{receive} keyword}
    \label{grafo:receive}
\end{figure}


\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={50mm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {1};
      \node[state] (n_2) [right of=n_1] {2};
      
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {ProcSent ! message} (n_2);
    \end{tikzpicture}
    \caption{Localview graph for the \texttt{!} keyword}
    \label{grafo:send}
\end{figure}

\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={40mm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {1};
      \node[state] (n_2) [right of=n_1] {2};
      
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {$\Delta$ process} (n_2);
    \end{tikzpicture}
    \caption{Localview graph for the \texttt{spawn} function}
    \label{grafo:spawn}
\end{figure}

\paragraph{Recursive calls}
In the case of \textit{recursive} calls, a transition $\epsilon$ is created from the last  
node generated to the first node, as shown in Figure \ref{grafo:ricors}.
For now, further evaluation of the function is blocked.

\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={3cm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {1};
      \node[state] (n_2) [right of=n_1] {\ldots};
      \node[state] (n_3) [right of=n_2] {$n$};
      
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {\ldots} (n_2);
      \draw[->] (n_2) -- node[midway, above, pos=0.5] {\ldots} (n_3);
      \draw[->] (n_3) to [out=120,in=60] node[midway, above, pos=0.5] {$\epsilon$} (n_1);
    \end{tikzpicture}
    \caption{Localview graph for a recursive call}
    \label{grafo:ricors}
\end{figure}

\paragraph{Function call}
When a call to an unknown function is encountered, the algorithm will create the local  
view of the called function and "connect" the beginning of the graph of the called  
function with the last state created in the local view of the calling function, linking  
them with an $\epsilon$ transition. The local view will continue from the last vertex of  
the call graph.

\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={2cm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {$1_a$};
      \node[state] (n_2) [right of=n_1] {\ldots};
      \node[state] (n_3) [right of=n_2] {$n$};
      \node[state] (n_4) [right of=n_3] {$1_b$};
      \node[state] (n_5) [right of=n_4] {\ldots};
      
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {\ldots} (n_2);
      \draw[->] (n_2) -- node[midway, above, pos=0.5] {\ldots} (n_3);
      \draw[->] (n_3) -- node[midway, above, pos=0.5] {$\epsilon$} (n_4);
      \draw[->] (n_4) -- node[midway, above, pos=0.5] {\ldots} (n_5);
    \end{tikzpicture}
    \caption{Localview graph of a function call}
    \label{grafo:funcall}
\end{figure}

In graph \ref{grafo:funcall}, state $1_a$ is the initial state of the calling function,  
and state $1_b$ represents the first state of the local view of the called function.

\paragraph{Global view}
For global views, in \texttt{spawn}, the actor performing the operation is specified to  
the left of the symbol, as shown in Figure \ref{grafo:globspawn}. A spawn will be  
directly inserted into the graph. Each process will also be numbered in case multiple  
actors are created for the same function.

\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={7cm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {1};
      \node[state] (n_2) [right of=n_1] {2};
      
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {ProcSpawner$_n\Delta$ProcSpawned$_m$} (n_2);
    \end{tikzpicture}
    \caption{Global view graph for the \texttt{spawn} function}
    \label{grafo:globspawn}
\end{figure}

For message sending and receiving, during the simulation of actors, if two actors are  
found executing a compatible \textit{send} and \textit{receive}, a state will be added  
to the global view as shown in Figure \ref{grafo:sendrecv}. To be compatible, the  
receiving process must match the data recipient, and the pattern matching of the  
\textit{receive} must correspond to the sent data. Transitions for \textit{send} and  
\textit{receive} that are ``empty" (i.e., messages that are sent but not processed by a  
\textit{receive} in any process) will not be shown in the global automaton.

\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}[node distance={8cm}, thick, main/.style = {draw, circle}] 
      \node[state] (n_1) {1};
      \node[state] (n_2) [right of=n_1] {2};
      
      \draw[->] (n_1) -- node[midway, above, pos=0.5] {ProcSender$_n\to$ ProcRecv$_m$ : message} (n_2);
    \end{tikzpicture}
    \caption{Global view graph for \texttt{receive} and \texttt{!} keywords}
    \label{grafo:sendrecv}
\end{figure}


\subsubsection{Main algorithms}
\input{content/algorithms}

\paragraph{Old state}

The tool can accurately parse the main constructs and features of the Erlang language. In Table \ref{erl}, we outline the current status: what is supported, what is not supported, and what are the next objectives. It was decided not to support certain constructs because they are not useful at this stage of the project. For example, supporting error handling with try-catch is unnecessary when variable passing is not yet implemented. Additionally, some constructs were excluded because they are orthogonal to others, such as complex data structures. The tool generates a local view that closely aligns with the behavior of the original actor, and the algorithm for combining local views into a global view performs well on simple examples. However, at present, it does not provide automatic error detection for certain properties in the global choreography.

% \begin{table}[!ht]
%     \centering
%     \begin{minipage}{0.49\textwidth}
%     \centering
%     \begin{tabular}{|c||c|}
%     \hline \textbf{Keyword} & \textbf{Support}    \\  \hline
%      atom & \cellcolor{ashgrey}yes    \\  \hline
%      integer & \cellcolor{ashgrey}yes \\   \hline
%      float &\cellcolor{ashgrey}yes    \\   \hline
%      boolean &\cellcolor{ashgrey}yes    \\   \hline
%      tuple & \cellcolor{ashgrey}yes    \\   \hline
%      list &\cellcolor{ashgrey}yes    \\   \hline
%      record & \cellcolor{red!50}no   \\   \hline
%      map & \cellcolor{red!50}no   \\   \hline
%      binary & \cellcolor{red!50}no    \\   \hline
%      if & \cellcolor{ashgrey}yes    \\   \hline
%      case & \cellcolor{ashgrey}yes    \\   \hline
%      receive &\cellcolor{ashgrey}yes    \\   \hline
%     \end{tabular}
%     \end{minipage}
%     \centering
%     \begin{minipage}{0.49\textwidth}
%     \begin{tabular}{|c||c|}
%     \hline \textbf{Keyword} & \textbf{Support}    \\  \hline
%      ! & \cellcolor{ashgrey}yes    \\   \hline
%      assignment &\cellcolor{ashgrey}yes    \\   \hline
%      function & \cellcolor{green!50}goal  \\   \hline
%      recursion & \cellcolor{green!50}goal   \\   \hline
%      hof &\cellcolor{green!50}goal    \\   \hline
%      when & \cellcolor{red!50}no    \\   \hline
%      self &\cellcolor{ashgrey}yes    \\   \hline
%      spawn &\cellcolor{ashgrey}yes    \\   \hline
%      rand:uniform &\cellcolor{ashgrey}yes    \\   \hline
%      try catch & \cellcolor{red!50}no    \\   \hline
%      after & \cellcolor{red!50}no    \\   \hline
%      math operation &\cellcolor{red!50}no    \\   \hline
%     \end{tabular} 
%     \end{minipage}
    
%     \caption{Supported constructs: Keywords in gray are already supported, keywords in red are not supported and are unlikely to be supported soon. Constructs in green are related to functions, because parameter passing is not supported.}
%     \label{erl}
% \end{table}