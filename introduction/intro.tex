The impetus of service-oriented computing and, more recently, of microservices has determined a radical shift from monolithic applications to distributed components cooperating through message-passing.
%
In this domain, \emph{choreographic} coordination~\cite{WS-CDL} allows designers to focus on the so-called \emph{application-level protocols}, i.e., a description of the \emph{communication interactions}\footnote{%
  With interaction, we refer to a full message-passing communication, comprised of both a send of a message and the corresponding receive.}  among the system's components (hereafter called
\emph{participants}).
% 
This focus is typically expressed by two distinct, yet related views
of distributed computations: the so-called \emph{global} and
\emph{local} views.
%
The former view abstracts away from the actual communication
infrastructure in order to give a blueprint of the communication
protocol.
%
The latter view provides the description of the communication
behavior of participants in isolation and can guide their
implementation.
Choreographies can be expressed in modeling languages or formalisms
(like WS-CDL~\cite{WS-CDL}, BPMN diagrams~\cite{BPMN}),
multiparty session types~\cite{HondaYC16}, message-sequence charts,
multiparty contracts, and many others (see also the survey
in~\cite{Huttel+16}).

Besides offering a suitable development for message-passing systems,
global views yield a high-level description of application-level
protocols.\footnote{According to the so-called top-down approach, a
  global view (formalized, e.g., as a multiparty session type) can be
  algorithmically projected on a local view preserving relevant
  properties.}
%
It is therefore crucial that global views faithfully capture
all the interactions in the system.
%
While this is relatively simple to guarantee when participants'
implementations are driven by the global view (e.g., in the top-down
approach), the correspondence can be easily spoiled when software
evolves or dynamic  composition  takes place (as advocated in
microservices architectures).
%
The classical top-down approach is then of little help: one needs to
write a global description of the desired behavior and then use type
checking or monitoring to find possible discrepancies.
