We have given above a number of requirements that our approach 
should satisfy, but some potential difficulties must be mentioned. 
A few problems that need to be solved in order to make such
an approach feasible. We describe them below, together with possible
mitigation measures:

\begin{description}
\item[Undecidability:]
  extracting a precise description of all the behaviors of a system
  is in general impossible, since it would require, e.g., deciding
  termination.
  %
  Hence, one can focus on extracting a precise choreography in
  simple cases and giving approximations of the behavior
  otherwise.
  %
  An \textbf{over-approximation} may exhibit different behaviors
  w.r.t.\ the actual behavior of the system.
  %
  Thus, one can understand the actual behavior, including bugs;
  however, it is necessary to verify if the reported bugs are false
  positives.
  %
  Therefore, care should be taken to limit the number of
  false positives, since a too high number would make the approach
  not viable.
  %
  Over-approximations can be too large: for example, if it is not
  possible to statically determine which is the expected recipient of a
  message, an over-approximated solution would be to create a different kind
  of execution for each participant where the recipient is always different.
  %
  When, as in the case discussed above, over-approximations are not
  suitable, an under-approximation may be more useful, possibly
  paired with warnings highlighting issues.
  %
  The problem in this case is to make sure that false negatives are
  avoided, i.e., cutting off misbehavior from extracted
  choreographies.

  \item[Huge descriptions:] choreographies of real programs may be
  huge, thus hindering their usefulness for program understanding.
  We believe this issue should be tackled by providing tools to
  abstract, explore, or better visualize the choreography. 
  For instance, one
  may decide that in order to understand a particular behavior interaction, 
  some participants are not of interest, hence should be
  removed (e.g., like $\epsilon$-transitions in automata based
  approaches). Another option to reduce the size of the description
  could be to collapse behaviors which are equal up to swap of
  concurrent actions (as in partial order reduction techniques
  within model checking \cite{God97}), or collapse the behaviors
  of multiple processes executing the same code.
\end{description}